<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jq on flavono123</title><link>https://flavono123.github.io/tags/jq/</link><description>Recent content in jq on flavono123</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Thu, 31 Mar 2022 17:57:16 +0900</lastBuildDate><atom:link href="https://flavono123.github.io/tags/jq/index.xml" rel="self" type="application/rss+xml"/><item><title>jq 커스텀 함수 라이브러리화</title><link>https://flavono123.github.io/posts/jq-library/</link><pubDate>Thu, 31 Mar 2022 17:57:16 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-library/</guid><description>이전 글 &amp;ldquo;jq 커스텀 함수 사용(Elasticsearch 프로퍼티 매핑 JSON 만들기)&amp;quot;에서 좀 불편한 점이 있다. -f 옵션을 단 하나만 쓰기 때문에 인자인 필터 파일 하나에 아주 작은 수정도 입력해야 한다. 실제로 &amp;ldquo;e&amp;rdquo; 경로를 보기 위해 | .e를 파일에 써 주었다. 길고 복잡해진 필터를 파일에 썼지만, 명령줄에서 파이프(합성)하여 쓰는 이점이 사라졌다.
이런 문제점을 해결하기 위해jq는 라이브러리(모듈) 기능을 제공한다.
&amp;ldquo;jq 필터로 JSON 정렬하기&amp;rdquo;에서 예로 든 JSON 정렬 필터를 예시로 들어 본다. 먼저 작업 디렉토리에 jqlib 라는 디렉토리를 만들고 아래 .</description></item><item><title>jq 커스텀 함수 사용(Elasticsearch 프로퍼티 매핑 JSON 만들기)</title><link>https://flavono123.github.io/posts/jq-custom-function/</link><pubDate>Wed, 30 Mar 2022 08:07:45 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-custom-function/</guid><description>Elasticsearch의 인덱스된 문서 필드에 데이터 타입이 동적으로 매핑이 된다. 하지만 인덱스 크기를 제한하기 위해 회사에선 명시적 매핑을 사용하고 있다.
그리고 회사에서 ES는 대부분 로그를 검색하는 용도로 쓰기 위해 사용하고 있다. 즉, ES 문서가 로그이다. 로그는 대부분 JSON이다. 그리고 매핑의 바디 역시 JSON이다. 따라서 내가 만들려는 것은 다음 같은 JSON 입출력의 jq 필터이다:
# 입력 ❯ cat input.json | jq { &amp;#34;a&amp;#34;: 11, &amp;#34;b&amp;#34;: 0.1 } # 출력 ❯ cat output.json | jq { &amp;#34;a&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;integer&amp;#34; }, &amp;#34;b&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;float&amp;#34; } } ES 매핑의 문법을 자세히 모르더라도 이해할 수 있도록 예시 JSON을 구성했다.</description></item><item><title>jq 필터로 JSON 정렬하기</title><link>https://flavono123.github.io/posts/jq-sort-json/</link><pubDate>Tue, 29 Mar 2022 20:16:40 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-sort-json/</guid><description>❯ jq --version jq-1.6 jq를 써 JSON을 정렬해보자. 정렬은 키를 기준으로 한다.
쿠버네티스 정의 파일을 편집하면 키 순서대로 정렬되어 있는것을 볼 수 있다(보통은 JSON이 아닌 YAML로 보긴한다). 긴 파일에서 키가 정렬되어 있는 것은 한눈에 보기에 편하다. 그래서인지 언제부턴가 다음 같은 JSON은 보기 불편하다. 예시로 쓸 JSON은 짧긴 하다:
❯ echo &amp;#39;{&amp;#34;b&amp;#34;:2,&amp;#34;a&amp;#34;:1}&amp;#39; | jq { &amp;#34;b&amp;#34;: 2, &amp;#34;a&amp;#34;: 1 } 중첩 없는 JSON 정렬하기 키를 기준으로 정렬할 것이다. jq엔 객체(JSON)의 키를 출력하는 keys와 배열을 정렬하는 sort라는 빌트인 함수가 있다:</description></item><item><title>nginx 설정 정적 분석</title><link>https://flavono123.github.io/posts/static-analysis-nginx-conf/</link><pubDate>Mon, 14 Feb 2022 19:13:48 +0900</pubDate><guid>https://flavono123.github.io/posts/static-analysis-nginx-conf/</guid><description>회사에선 nginx를 웹 서버이자 리버스 프록시로 여러군데서 쓰고 있다. 설정 파일을 레일즈 배포 시 ERB로 템플릿하고 있다. 그래서 설정 내용이 레일즈 앱에 종속적이기도 하고(배포 변수가 레일즈 앱에 연관이 있을 시), 엄청 길다.
이걸 간편하게 바꿀 임무가 주어졌다. 2000줄이 넘는 설정 파일이라 단순히 눈으로 보며 고치긴 어려울거 같아, 구조를 파싱한 후 정적으로 분석해보기로 했다.
crossplane 먼저 nginx 설정 파일을 구조를 파싱할 수 있는 도구가 있을거 같아 찾아봤다. crossplane이라는 NGINX, Inc.에서 파이썬으로 만든 도구가 있다.</description></item><item><title>jq descendants</title><link>https://flavono123.github.io/posts/jq-descendants/</link><pubDate>Mon, 14 Feb 2022 12:08:56 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-descendants/</guid><description>JSON을 다루다 보면 객체가 중첩(nested), 재귀적인(recursive) 구조가 있다. 객체 안엔 자식 객체를 담는 배열 애트리뷰트가 있고, 그 배열이 비어 있거나 또는 애트리뷰트(= 키 자체)가 없는 경우까지 반복 된다:
{ &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val2&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val4&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val6&amp;#34;, &amp;#34;children&amp;#34;: [], &amp;#34;__comment&amp;#34;: &amp;#34;더 이상 children이 없거나&amp;#34; }, { &amp;#34;key1&amp;#34;: &amp;#34;val7&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val8&amp;#34; &amp;#34;__comment&amp;#34;: &amp;#34;아예 children 키가 없다&amp;#34; }, ] }, { &amp;#34;key1&amp;#34;: &amp;#34;val9&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val10&amp;#34; }, ] } 이 때 특정 조건을 만족하는 객체만 필터해야 할 때가 있다.</description></item></channel></rss>