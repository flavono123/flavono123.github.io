<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jq on flavono123</title><link>https://flavono123.github.io/tags/jq/</link><description>Recent content in jq on flavono123</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 14 Feb 2022 19:13:48 +0900</lastBuildDate><atom:link href="https://flavono123.github.io/tags/jq/index.xml" rel="self" type="application/rss+xml"/><item><title>nginx 설정 정적 분석</title><link>https://flavono123.github.io/posts/static-analysis-nginx-conf/</link><pubDate>Mon, 14 Feb 2022 19:13:48 +0900</pubDate><guid>https://flavono123.github.io/posts/static-analysis-nginx-conf/</guid><description>회사에선 nginx를 웹 서버이자 리버스 프록시로 여러군데서 쓰고 있다. 설정 파일을 레일즈 배포 시 ERB로 템플릿하고 있다. 그래서 설정 내용이 레일즈 앱에 종속적이기도 하고(배포 변수가 레일즈 앱에 연관이 있을 시), 엄청 길다.
이걸 간편하게 바꿀 임무가 주어졌다. 2000줄이 넘는 설정 파일이라 단순히 눈으로 보며 고치긴 어려울거 같아, 구조를 파싱한 후 정적으로 분석해보기로 했다.
crossplane 먼저 nginx 설정 파일을 구조를 파싱할 수 있는 도구가 있을거 같아 찾아봤다. crossplane이라는 NGINX, Inc.에서 파이썬으로 만든 도구가 있다.</description></item><item><title>jq descendants</title><link>https://flavono123.github.io/posts/jq-descendants/</link><pubDate>Mon, 14 Feb 2022 12:08:56 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-descendants/</guid><description>JSON을 다루다 보면 객체가 중첩(nested), 재귀적인(recursive) 구조가 있다. 객체 안엔 자식 객체를 담는 배열 애트리뷰트가 있고, 그 배열이 비어 있거나 또는 애트리뷰트(= 키 자체)가 없는 경우까지 반복 된다:
{ &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val2&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val4&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val6&amp;#34;, &amp;#34;children&amp;#34;: [], &amp;#34;__comment&amp;#34;: &amp;#34;더 이상 children이 없거나&amp;#34; }, { &amp;#34;key1&amp;#34;: &amp;#34;val7&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val8&amp;#34; &amp;#34;__comment&amp;#34;: &amp;#34;아예 children 키가 없다&amp;#34; }, ] }, { &amp;#34;key1&amp;#34;: &amp;#34;val9&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val10&amp;#34; }, ] } 이 때 특정 조건을 만족하는 객체만 필터해야 할 때가 있다.</description></item></channel></rss>