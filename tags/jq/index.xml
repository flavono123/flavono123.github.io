<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jq on flavono123</title><link>https://flavono123.github.io/tags/jq/</link><description>Recent content in jq on flavono123</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 29 Mar 2022 20:16:40 +0900</lastBuildDate><atom:link href="https://flavono123.github.io/tags/jq/index.xml" rel="self" type="application/rss+xml"/><item><title>jq 필터로 JSON 정렬하기</title><link>https://flavono123.github.io/posts/jq-sort-json/</link><pubDate>Tue, 29 Mar 2022 20:16:40 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-sort-json/</guid><description>❯ jq --version jq-1.6 jq를 써 JSON을 정렬해보자. 정렬은 키를 기준으로 한다.
쿠버네티스 정의 파일을 편집하면 키 순서대로 정렬되어 있는것을 볼 수 있다(보통은 JSON이 아닌 YAML로 보긴한다). 긴 파일에서 키가 정렬되어 있는 것은 한눈에 보기에 편하다. 그래서인지 언제부턴가 다음 같은 JSON은 보기 불편하다. 예시로 쓸 JSON은 짧긴 하다:
❯ echo &amp;#39;{&amp;#34;b&amp;#34;:2,&amp;#34;a&amp;#34;:1}&amp;#39; | jq { &amp;#34;b&amp;#34;: 2, &amp;#34;a&amp;#34;: 1 } 중첩 없는 JSON 정렬하기 키를 기준으로 정렬할 것이다. jq엔 객체(JSON)의 키를 출력하는 keys와 배열을 정렬하는 sort라는 빌트인 함수가 있다:</description></item><item><title>nginx 설정 정적 분석</title><link>https://flavono123.github.io/posts/static-analysis-nginx-conf/</link><pubDate>Mon, 14 Feb 2022 19:13:48 +0900</pubDate><guid>https://flavono123.github.io/posts/static-analysis-nginx-conf/</guid><description>회사에선 nginx를 웹 서버이자 리버스 프록시로 여러군데서 쓰고 있다. 설정 파일을 레일즈 배포 시 ERB로 템플릿하고 있다. 그래서 설정 내용이 레일즈 앱에 종속적이기도 하고(배포 변수가 레일즈 앱에 연관이 있을 시), 엄청 길다.
이걸 간편하게 바꿀 임무가 주어졌다. 2000줄이 넘는 설정 파일이라 단순히 눈으로 보며 고치긴 어려울거 같아, 구조를 파싱한 후 정적으로 분석해보기로 했다.
crossplane 먼저 nginx 설정 파일을 구조를 파싱할 수 있는 도구가 있을거 같아 찾아봤다. crossplane이라는 NGINX, Inc.에서 파이썬으로 만든 도구가 있다.</description></item><item><title>jq descendants</title><link>https://flavono123.github.io/posts/jq-descendants/</link><pubDate>Mon, 14 Feb 2022 12:08:56 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-descendants/</guid><description>JSON을 다루다 보면 객체가 중첩(nested), 재귀적인(recursive) 구조가 있다. 객체 안엔 자식 객체를 담는 배열 애트리뷰트가 있고, 그 배열이 비어 있거나 또는 애트리뷰트(= 키 자체)가 없는 경우까지 반복 된다:
{ &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val2&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val4&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val6&amp;#34;, &amp;#34;children&amp;#34;: [], &amp;#34;__comment&amp;#34;: &amp;#34;더 이상 children이 없거나&amp;#34; }, { &amp;#34;key1&amp;#34;: &amp;#34;val7&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val8&amp;#34; &amp;#34;__comment&amp;#34;: &amp;#34;아예 children 키가 없다&amp;#34; }, ] }, { &amp;#34;key1&amp;#34;: &amp;#34;val9&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val10&amp;#34; }, ] } 이 때 특정 조건을 만족하는 객체만 필터해야 할 때가 있다.</description></item></channel></rss>