<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nginx on flavono123</title><link>https://flavono123.github.io/tags/nginx/</link><description>Recent content in nginx on flavono123</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 26 Apr 2022 17:41:35 +0900</lastBuildDate><atom:link href="https://flavono123.github.io/tags/nginx/index.xml" rel="self" type="application/rss+xml"/><item><title>Nginx OCSP Stapling 경고 재현하기</title><link>https://flavono123.github.io/posts/ocsp-stapling/</link><pubDate>Tue, 26 Apr 2022 17:41:35 +0900</pubDate><guid>https://flavono123.github.io/posts/ocsp-stapling/</guid><description>nginx: [warn] &amp;#34;ssl_stapling&amp;#34; ignored, issuer certificate not found for certificate &amp;#34;/path/to/cert&amp;#34; TLS 인증서를 교체하고 Nginx 설정 테스트(nginx -t)를 해보았는데 위 경고가 나왔다. 테스트할 서버부터 적용했는데 인증과 파일 서빙 자체는 잘 되었다. 위 메세지로 검색하다 보니 CRL, OCSP 등의 처음 보는 개념을 알게 됐고, 로컬 Nginx에서 위와 같은 문제를 재현하고 해결할 수 있었다.
CRL 먼저 앞서 말한 CRL과 OCSP는 인증서 폐기(Certificate Revocation)에 관련한 용어이다. 보통 인증서에 문제가 있으면 새로 발급을 받더라도 이전 것이 폐기 됐는지 안했던터라 조금 생소했다.</description></item><item><title>nginx location 점프</title><link>https://flavono123.github.io/posts/nginx-location-jump/</link><pubDate>Fri, 25 Feb 2022 12:33:29 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-location-jump/</guid><description>지난 포스트, nginx 블록 선택 알고리즘, 에서 테스트와 설명에 자신감이 없던 부분에 대한 보충 설명이다. Understanding Nginx Server and Location Block Selection Algorithms를 참고하여 location 컨텍스트 내에서 다시 location 탐색을 유발하는 디렉티브 네개를 소개했다:
index try_files rewrite error_page 이 중 세개는 테스트해봤다. 첫번째인 index 디렉티브는 검증하지 못했다. 디지털 오션 참고 글엔 location 컨텍스트가 비어 있어, index 디렉티브를 상속 받는게 아니라 각각 써주었다:
... location = /exact { index index.</description></item><item><title>nginx 블록 선택 알고리즘</title><link>https://flavono123.github.io/posts/nginx-block-selection/</link><pubDate>Sat, 19 Feb 2022 17:07:52 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-block-selection/</guid><description>지난 포스트 웹 서버/리버스 프록시로서 nginx 설정 구조(HTTP)와 nginx 설정 정적 분석에서 이어지는 내용이다.
nginx 설정은 server와 location 디렉티브를 정의하여 요청이 어떻게 처리할지 정하게 된다. 이 글은 Understanding Nginx Server and Location Block Selection Algorithms를 읽고 이해한 일부 내용을 정리한다(다 이해하진 못했는데 이 부분은 나중에 설정을 바꿔가며 직접 테스트 해보는걸로 미뤄둔다..).
server 블록 선택 알고리즘 server 블록은 요청에서 IP와 포트 그리고 Host 헤더 관련한 부분을 필터하여 가상 서버를 선택한다.
listen 먼저 listen 디렉티브 인자로 매치할 IP와 포트를 정의한다(소켓 경로도 인자로 받을 수 있으나 여기서 다루진 않는다).</description></item><item><title>nginx 설정 정적 분석</title><link>https://flavono123.github.io/posts/static-analysis-nginx-conf/</link><pubDate>Mon, 14 Feb 2022 19:13:48 +0900</pubDate><guid>https://flavono123.github.io/posts/static-analysis-nginx-conf/</guid><description>회사에선 nginx를 웹 서버이자 리버스 프록시로 여러군데서 쓰고 있다. 설정 파일을 레일즈 배포 시 ERB로 템플릿하고 있다. 그래서 설정 내용이 레일즈 앱에 종속적이기도 하고(배포 변수가 레일즈 앱에 연관이 있을 시), 엄청 길다.
이걸 간편하게 바꿀 임무가 주어졌다. 2000줄이 넘는 설정 파일이라 단순히 눈으로 보며 고치긴 어려울거 같아, 구조를 파싱한 후 정적으로 분석해보기로 했다.
crossplane 먼저 nginx 설정 파일을 구조를 파싱할 수 있는 도구가 있을거 같아 찾아봤다. crossplane이라는 NGINX, Inc.에서 파이썬으로 만든 도구가 있다.</description></item><item><title>웹 서버/리버스 프록시로서 nginx 설정 구조(HTTP)</title><link>https://flavono123.github.io/posts/nginx-conf-structure/</link><pubDate>Mon, 14 Feb 2022 13:12:46 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-conf-structure/</guid><description>nginx 설정을 바꾸고 재적용(reload) 전 테스트 시 오류를 본적이 있다:
$ sudo nginx -t -c /path/to/nginx.conf nginx: [emerg] &amp;#34;upstream&amp;#34; directive is not allowed here in /path/to/nginx.conf:6 upstream 디렉티브는 원래부터 저 위치에 있었고, 다른 컨텍스트 내부를 수정한거라 원인이 뭔지 몰랐다. 과거에 이렇게 잘 몰랐다가 nginx 설정을 파싱할 일이 있어 해보았는데 같은 에러를 만났다. 따라서, 제대로 공부한적 없는, nginx 설정에 대해 한번 정리해본다(디렉티브 및 컨텍스트는 회사에서 쓰고 있는 것만 정리했다).
기본 설정 파일 nginx는 설정을 읽어 오는 기본 파일 경로가 있다:</description></item><item><title>Self-signed Certificate(NGINX)</title><link>https://flavono123.github.io/posts/self-signed-certificate/</link><pubDate>Sat, 05 Feb 2022 13:25:51 +0900</pubDate><guid>https://flavono123.github.io/posts/self-signed-certificate/</guid><description>0. 준비 openssl3 kubernetes(minikube) 1. CA RSA 키 페어 생성 실제 CA가 아니라 우리가 직접 CA를 만들어 TLS 인증하는 과정을 모의로 해본다(self-signed certificate)
$ openssl genrsa -aes256 -out rootCA.key 2048 Enter PEM pass phrase: Verifying - Enter PEM pass phrase: $ ll rootCA.key -rw------- 1 hansuk staff 1874 Jan 14 14:30 rootCA.key 비밀키 분실을 대비하여 AES256으로 암호화 한다. 이때 passphrase를 잘 기억하고 발급할 때 사용하자 2. CA 인증서 발급 $ openssl req -x509 -new -nodes -key rootCA.</description></item></channel></rss>