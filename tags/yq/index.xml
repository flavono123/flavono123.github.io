<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>yq on flavono123</title><link>https://flavono123.github.io/tags/yq/</link><description>Recent content in yq on flavono123</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 20 Jun 2022 19:40:31 +0900</lastBuildDate><atom:link href="https://flavono123.github.io/tags/yq/index.xml" rel="self" type="application/rss+xml"/><item><title>Yq 중첩 키 경로 파악하기(긴 Helm 차트 values 파악하기)</title><link>https://flavono123.github.io/posts/yq-parse-long-nested-helm-values/</link><pubDate>Mon, 20 Jun 2022 19:40:31 +0900</pubDate><guid>https://flavono123.github.io/posts/yq-parse-long-nested-helm-values/</guid><description>Yq의 globbing과 내장 연산자 몇가지를 사용하면 중첩된 객체에서 특정 키 경로를 알아낼 수 있다:
❯ cat test.yaml a: b: target: HERE ❯ yq e &amp;#39; .. | select(has(&amp;#34;target&amp;#34;)) | path&amp;#39; test.yaml - a - b 실전으론, 아주 긴 쿠버네티스 매니페스트나 Helm values를 파악할 때 사용할 수 있다. 하지만 내가 쓰는 방법이 완전한 해결책이라는 생각이 들진 않는데&amp;hellip; 일단 지금 쓰는 방식을 이야기 해본다.
한 예로 kube-prometheus-stack의 values는 아주 길다:
$ helm show values prometheus-community/kube-prometheus-stack --version 36.</description></item></channel></rss>