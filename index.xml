<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>flavono123</title><link>https://flavono123.github.io/</link><description>Recent content on flavono123</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sat, 19 Feb 2022 17:07:52 +0900</lastBuildDate><atom:link href="https://flavono123.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>nginx 블록 선택 알고리즘</title><link>https://flavono123.github.io/posts/nginx-block-selection/</link><pubDate>Sat, 19 Feb 2022 17:07:52 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-block-selection/</guid><description>지난 포스트 웹 서버/리버스 프록시로서 nginx 설정 구조(HTTP)와 nginx 설정 정적 분석에서 이어지는 내용이다.
nginx 설정은 server와 location 디렉티브를 정의하여 요청이 어떻게 처리할지 정하게 된다. 이 글은 Understanding Nginx Server and Location Block Selection Algorithms를 읽고 이해한 일부 내용을 정리한다(다 이해하진 못했는데 이 부분은 나중에 설정을 바꿔가며 직접 테스트 해보는걸로 미뤄둔다..).
server 블록 선택 알고리즘 server 블록은 요청에서 IP와 포트 그리고 Host 헤더 관련한 부분을 필터하여 가상 서버를 선택한다.
listen 먼저 listen 디렉티브 인자로 매치할 IP와 포트를 정의한다(소켓 경로도 인자로 받을 수 있으나 여기서 다루진 않는다).</description></item><item><title>맥에서 kubectl bash 자동 완성 기능 켜기</title><link>https://flavono123.github.io/posts/kubectl-bash-auto-completion-in-mac/</link><pubDate>Thu, 17 Feb 2022 16:06:33 +0900</pubDate><guid>https://flavono123.github.io/posts/kubectl-bash-auto-completion-in-mac/</guid><description>쿠버네티스 문서 bash 자동완성 안내처럼 $HOME/.bash_profile에 코드를 추가했는데, 자동완성이 되질 않는다:
❯ tail -3 ~/.bash_profile source &amp;lt;(kubectl completion bash) alias k=kubectl complete -F __start_kubectl k ❯ k ap-bash: completion: function `__start_kubectl&amp;#39; not found # k apply 치고 싶어! 구글링 결과 다른 문서를 찾게 됐다. 안되는 이유는 맥 시스템의 기본 bash 버전에선 자동완성이 지원되지 않기 때문이다.
아마 위와 같은 문제를 겪고 있다면 bash 버전은 4.1 미만, 맥 시스템 bash(/bin/bash)를 쓰고 있을 감능성이 높다:</description></item><item><title>MariaDB semi-join과 구체화 뷰</title><link>https://flavono123.github.io/posts/mariadb-semi-join/</link><pubDate>Wed, 16 Feb 2022 17:39:28 +0900</pubDate><guid>https://flavono123.github.io/posts/mariadb-semi-join/</guid><description>MariaDB Knowledge Base 다음 두 포스트를 따라하며 semi-join과 구체화 뷰 대해 이해한 점을 정리한다:
https://mariadb.com/kb/en/semi-join-subquery-optimizations/ https://mariadb.com/kb/en/semi-join-materialization-strategy/ 한번씩 읽어야 이 글도 이해가 빠를것 같다.
원랜 회사에서 겪은 DB 이슈를 공유하고 싶었는데, 한번에 글로 정리가 안되어 쪼개어 쓴다(DB 이슈는 이 글을 참고해서 이어서 쓸 예정이다).
준비 우선 Homebrew로 받은 MariaDB 10.3.32에서 테스트했다:
❯ mysql --version mysql Ver 15.1 Distrib 10.3.32-MariaDB, for osx10.16 (x86_64) using readline 5.1 MariaDB Knowlege Base(kb)의 쿼리를 따라하기 위해 샘플 데이터를 받는다.</description></item><item><title>nginx 설정 정적 분석</title><link>https://flavono123.github.io/posts/static-analysis-nginx-conf/</link><pubDate>Mon, 14 Feb 2022 19:13:48 +0900</pubDate><guid>https://flavono123.github.io/posts/static-analysis-nginx-conf/</guid><description>회사에선 nginx를 웹 서버이자 리버스 프록시로 여러군데서 쓰고 있다. 설정 파일을 레일즈 배포 시 ERB로 템플릿하고 있다. 그래서 설정 내용이 레일즈 앱에 종속적이기도 하고(배포 변수가 레일즈 앱에 연관이 있을 시), 엄청 길다.
이걸 간편하게 바꿀 임무가 주어졌다. 2000줄이 넘는 설정 파일이라 단순히 눈으로 보며 고치긴 어려울거 같아, 구조를 파싱한 후 정적으로 분석해보기로 했다.
crossplane 먼저 nginx 설정 파일을 구조를 파싱할 수 있는 도구가 있을거 같아 찾아봤다. crossplane이라는 NGINX, Inc.에서 파이썬으로 만든 도구가 있다.</description></item><item><title>웹 서버/리버스 프록시로서 nginx 설정 구조(HTTP)</title><link>https://flavono123.github.io/posts/nginx-conf-structure/</link><pubDate>Mon, 14 Feb 2022 13:12:46 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-conf-structure/</guid><description>nginx 설정을 바꾸고 재적용(reload) 전 테스트 시 오류를 본적이 있다:
$ sudo nginx -t -c /path/to/nginx.conf nginx: [emerg] &amp;#34;upstream&amp;#34; directive is not allowed here in /path/to/nginx.conf:6 upstream 디렉티브는 원래부터 저 위치에 있었고, 다른 컨텍스트 내부를 수정한거라 원인이 뭔지 몰랐다. 과거에 이렇게 잘 몰랐다가 nginx 설정을 파싱할 일이 있어 해보았는데 같은 에러를 만났다. 따라서, 제대로 공부한적 없는, nginx 설정에 대해 한번 정리해본다(디렉티브 및 컨텍스트는 회사에서 쓰고 있는 것만 정리했다).
기본 설정 파일 nginx는 설정을 읽어 오는 기본 파일 경로가 있다:</description></item><item><title>jq descendants</title><link>https://flavono123.github.io/posts/jq-descendants/</link><pubDate>Mon, 14 Feb 2022 12:08:56 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-descendants/</guid><description>JSON을 다루다 보면 객체가 중첩(nested), 재귀적인(recursive) 구조가 있다. 객체 안엔 자식 객체를 담는 배열 애트리뷰트가 있고, 그 배열이 비어 있거나 또는 애트리뷰트(= 키 자체)가 없는 경우까지 반복 된다:
{ &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val2&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val4&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val6&amp;#34;, &amp;#34;children&amp;#34;: [], &amp;#34;__comment&amp;#34;: &amp;#34;더 이상 children이 없거나&amp;#34; }, { &amp;#34;key1&amp;#34;: &amp;#34;val7&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val8&amp;#34; &amp;#34;__comment&amp;#34;: &amp;#34;아예 children 키가 없다&amp;#34; }, ] }, { &amp;#34;key1&amp;#34;: &amp;#34;val9&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val10&amp;#34; }, ] } 이 때 특정 조건을 만족하는 객체만 필터해야 할 때가 있다.</description></item><item><title>Self-signed Certificate(NGINX)</title><link>https://flavono123.github.io/posts/self-signed-certificate/</link><pubDate>Sat, 05 Feb 2022 13:25:51 +0900</pubDate><guid>https://flavono123.github.io/posts/self-signed-certificate/</guid><description>0. 준비 openssl3 kubernetes(minikube) 1. CA RSA 키 페어 생성 실제 CA가 아니라 우리가 직접 CA를 만들어 TLS 인증하는 과정을 모의로 해본다(self-signed certificate)
$ openssl genrsa -aes256 -out rootCA.key 2048 Enter PEM pass phrase: Verifying - Enter PEM pass phrase: $ ll rootCA.key -rw------- 1 hansuk staff 1874 Jan 14 14:30 rootCA.key 비밀키 분실을 대비하여 AES256으로 암호화 한다. 이때 passphrase를 잘 기억하고 발급할 때 사용하자 2. CA 인증서 발급 $ openssl req -x509 -new -nodes -key rootCA.</description></item><item><title>CKA with Practice Tests: Logging &amp; Monitoring(+ Prometheus, Grafana)</title><link>https://flavono123.github.io/posts/cka-4-logging-monitoring/</link><pubDate>Tue, 25 Jan 2022 17:33:38 +0900</pubDate><guid>https://flavono123.github.io/posts/cka-4-logging-monitoring/</guid><description>클러스터 컴포넌트 모니터 모니터 대상은 크게 노드와 파드 두개로 나뉜다. 기본적인 메트릭 API 있다. 이를 집계하려면 별도의 메트릭 서버가 필요하다.
먼저 로컬에 구성한 minikube의 경우 metrics-server를 애드온으로 추가하면 kubectl top 명령으로 CPU와 메모리 사용량을 알 수 있다.
❯ minikube version minikube version: v1.24.0 commit: 76b94fb3c4e8ac5062daf70d60cf03ddcc0a741b ❯ minikube addons enable metrics-server ▪ Using image k8s.gcr.io/metrics-server/metrics-server:v0.4.2 🌟 &amp;#39;metrics-server&amp;#39; 애드온이 활성화되었습니다 ❯ minikube addons list |-----------------------------|----------|--------------|-----------------------| | ADDON NAME | PROFILE | STATUS | MAINTAINER | |-----------------------------|----------|--------------|-----------------------| | ambassador | minikube | disabled | unknown (third-party) | | auto-pause | minikube | disabled | google | | csi-hostpath-driver | minikube | disabled | kubernetes | | dashboard | minikube | disabled | kubernetes | | default-storageclass | minikube | enabled ✅ | kubernetes | | efk | minikube | disabled | unknown (third-party) | | freshpod | minikube | disabled | google | | gcp-auth | minikube | disabled | google | | gvisor | minikube | disabled | google | | helm-tiller | minikube | disabled | unknown (third-party) | | ingress | minikube | disabled | unknown (third-party) | | ingress-dns | minikube | disabled | unknown (third-party) | | istio | minikube | disabled | unknown (third-party) | | istio-provisioner | minikube | disabled | unknown (third-party) | | kubevirt | minikube | disabled | unknown (third-party) | | logviewer | minikube | disabled | google | | metallb | minikube | disabled | unknown (third-party) | | metrics-server | minikube | enabled ✅ | kubernetes | | nvidia-driver-installer | minikube | disabled | google | | nvidia-gpu-device-plugin | minikube | disabled | unknown (third-party) | | olm | minikube | disabled | unknown (third-party) | | pod-security-policy | minikube | disabled | unknown (third-party) | | portainer | minikube | disabled | portainer.</description></item><item><title>CKA with Practice Tests 정리: Scheduler</title><link>https://flavono123.github.io/posts/cka-3-scheduler/</link><pubDate>Sun, 23 Jan 2022 13:21:29 +0900</pubDate><guid>https://flavono123.github.io/posts/cka-3-scheduler/</guid><description>Manage scheduling 스케줄러는 파드를 어떤 노드에 할당(bind)할지 판단한다. 지금까지 파드 생성 시 정의에 명시하지 않았지만, spec.nodeName에 할당할 파드를 명시할 수 있다. 이런 방법은 추천하지 않는것 같고, 스케줄러에게 맡기되 그걸 제어할 수 있는 방법을 이번 장에서 다룬다.
스케줄러는 core Binding API(target.kind: Node)를 이용해 특정 노드에 파드 할당을 요청한다.
스케줄러는 컨트롤플레인 노드에서, 뒤에서 설명할, 스태틱 파드로 실행중이다:
❯ kubectl describe po kube-scheduler-minikube -n kube-system | grep Controlled Controlled By: Node/minikube 레이블 &amp;amp; 셀렉터 레이블: 쿠버네티스 오브젝트를 특정하기 위한 태그.</description></item><item><title>Elasticsearch를 공부하고 DDIA를 다시 읽어보았다</title><link>https://flavono123.github.io/posts/elasticsearch-and-ddia/</link><pubDate>Fri, 21 Jan 2022 15:43:56 +0900</pubDate><guid>https://flavono123.github.io/posts/elasticsearch-and-ddia/</guid><description>사내에서 Elasticsearch 스터디를 진행 중이다. 특히 키바나(쿼리와 시각화)를 더 잘 쓰고 싶어서 이 주제를 하자고 주장했다. 그런데 우리가 스터디 하는 2~3개월 정도 기간에 가이드가 될만한 책이나 강의가 마땅치 않아, 스터디 진행 구성도 오밀조밀하게 직접했다. 그중 첫단계는 Elastic 가이드 북을 한번 읽는 것인데 이제 막 끝났다.
일단 너무 재밌었다. 내가 알고 싶었던 것은, match 쿼리 결과가 왜 생각하는대로 안나오는지, terms aggregation에 왜 이런 결과가 있는지, 같은 것인데 이를 다 해소할 수 있었다.</description></item><item><title>CKA with Practice Tests 정리: Core Concepts</title><link>https://flavono123.github.io/posts/cka-2-core-concept/</link><pubDate>Sat, 15 Jan 2022 17:09:34 +0900</pubDate><guid>https://flavono123.github.io/posts/cka-2-core-concept/</guid><description>쿠버네티스에 대한 관심이 생기며 CKA란 자격증도 알게 됐다. 원랜 개발 관련한 자격증은 막연한 편견이 있었다. 실무와 거리가 멀것만 같은&amp;hellip; 하지만 시험이 프롬프트를 통해 쿠버네티스 상태를 만든다는 점에서 그런 편견이 깨졌다. 무엇보다 회사에서 아직 쿠버네티스를 쓰지 않으니 배울 수 있는 좋은 기회인거 같아 자격증 준비를 시작했다.
아주 유명한 Udemy 강의인 Certified Kubernetes Administrator (CKA) with Practice Tests를 듣고 있다. 강의를 들은 후 섹션별로 내용을 정리할 계획이다.
쿠버네티스 문서화가 잘 되어 있고 한글 번역된것도 많다.</description></item><item><title>SSL/TLS 인증서 동작 이해하기 1</title><link>https://flavono123.github.io/posts/understand-tls-certificate-with-hand-on-practice-1/</link><pubDate>Wed, 12 Jan 2022 23:21:42 +0900</pubDate><guid>https://flavono123.github.io/posts/understand-tls-certificate-with-hand-on-practice-1/</guid><description>작년에 회사에서 SSL/TLS 인증서 갱신 작업을 했다. 회사가 합병과 이사를 해서 정보가 바뀌어 CSR 생성부터 모든 과정을 했다. 당시엔 연마다 반복해야하는 작업이니 절차를 매뉴얼화 했다. 실제로 권한이 있고 명령어 복붙하면 비개발자 또는 웹 통신과 보안에 이해가 전혀 없는 사람도 할 수 있을 정도로 만들었다.
올해 다시 인증서 갱신하려 보니 내가 그런 사람인거 같았다. 실제로 인증서의 암호화나 인증 과정을 정확히 몰랐다. 따라서 SSL/TLS 인증과 관련한 키워드 검색해서 공부했다. 하지만 내가 단번에 이해할 수 있는 글은 없었다(물론 크게 도움이 된 글도 있다).</description></item><item><title>Minikube에서 NodePort 서비스 로컬 프라이빗 IP 찾기</title><link>https://flavono123.github.io/posts/minikube-service-private-ip/</link><pubDate>Fri, 07 Jan 2022 10:44:54 +0900</pubDate><guid>https://flavono123.github.io/posts/minikube-service-private-ip/</guid><description>minikube service --url &amp;lt;service-name&amp;gt; NodePort 서비스를 만들어 포트는 노출시켰는데 어느 IP로 접속할지 몰라 한참을 헤맸다&amp;hellip;
출처: https://minikube.sigs.k8s.io/docs/handbook/accessing/#getting-the-nodeport-using-the-service-command</description></item><item><title>Datadog의 이상치 감지 알고리즘: DBSCAN과 MAD</title><link>https://flavono123.github.io/posts/outlier-detection-dbscan-mad/</link><pubDate>Wed, 05 Jan 2022 22:39:59 +0900</pubDate><guid>https://flavono123.github.io/posts/outlier-detection-dbscan-mad/</guid><description>https://docs.datadoghq.com/monitors/create/types/outlier/?tab=dbscan
Datadog 모니터에선 기본적으로 한계치 알람(threshold alerts) 기능이 있다. 하지만 다음과 같은 시계열(timeserires) 그래프의 패턴은 알람의 기준을 threshold로 정할 수 없다:
스파이크나 아발란체를 예상할 수 있다. 예를 들어 밤 같은 특정 시간대에만 스루풋이 높아져 스파이크가 생긴다면 이는 알람으로 받고 싶지 않다. 값의 기준선이 요동친다(fluctuate). 물론 두번째의 경우 threshold 최소, 최대치를 높이는 방법도 생각할 수 있다. 대신 클러스터링 알고리즘과 통계적인 방법으로 이상치를 감지할 수 있다. DBSCAN DBSCAN(Density-Based Spatial Clustering of Appplication with Noise)은 클러스터링 알고리즘이다.</description></item><item><title>Minikube로 Docker Desktop를 대체해보며 쿠버네티스 통빡으로 맞춰보기</title><link>https://flavono123.github.io/posts/minikube-replace-docker-desktop/</link><pubDate>Tue, 04 Jan 2022 00:51:44 +0900</pubDate><guid>https://flavono123.github.io/posts/minikube-replace-docker-desktop/</guid><description>https://novemberde.github.io/post/2021/09/02/podman-minikube/
이 글을 읽고 회사 개발 계정 메일로 오던 도커에서 프로모 코드 뿌리는, 확인 안하던, 메일들이 생각났다.
역시 도커 데스크탑이 유료로 바뀌니 주는 할인 코드였고 마침 쿠버네티스에 대한 관심도가 마구마구 오르는 시기라 호기롭게 위 포스팅을 따라하였다.
도커 데스크탑을 삭제하고 minikube 와 kompose 설치, 기존 docker-compose 파일을 변환해서 apply 까지 마쳤다. 마침 대상으로 해본 docker-compose 의 이미지들은 어차피 로컬(맥)에선 잘 안도는거라, 컨테이너가 잘 띄워졌는지 확인하진 않았다(솔직히 쿠버네티스도 컨테이너를 띄우는가? 도커를 대체한다니깐 그러지 않을까?</description></item><item><title>카프카 컨슈머 메트릭 수집 이란 글을 쓴 후</title><link>https://flavono123.github.io/posts/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EB%A9%94%ED%8A%B8%EB%A6%AD-%EC%88%98%EC%A7%91-%EC%9D%B4%EB%9E%80-%EA%B8%80%EC%9D%84-%EC%93%B4-%ED%9B%84/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://flavono123.github.io/posts/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EB%A9%94%ED%8A%B8%EB%A6%AD-%EC%88%98%EC%A7%91-%EC%9D%B4%EB%9E%80-%EA%B8%80%EC%9D%84-%EC%93%B4-%ED%9B%84/</guid><description>https://crema.github.io/2021/06/29/collect-kafka-consumer-metrics.html
이런 글을 썼었다.
글을 쓰는덴, 위 링크 본문에도 참조되어 있는
https://www.theteams.kr/teams/865/post/64574
이 글이 많이 동기가 되었다.
글을 처음 쓰기 시작할 때의 목표?는, 이러한 점을 말하고 싶었다:
크리마는 Ansible 을 쓰고 있다. 크리마는 Datadog 을 쓰고 있다. 크리마는 Kafka 도 쫌 쓰고 있다. 누가 봤을진 모르지만(우리 회사 사람들은 봤을까 싶다..), 그래도 목표한 바는 글에 잘 쓴거 같다.
글 쓴 후 아쉬운 점을 복기하자면, 참고한 원 글에선 outlier detection 알람을 걸었다고 한다(정확히 알람일진 모르겠지만, 내 생각에 티켓 정도로 보내면 좋을거 같다).</description></item></channel></rss>