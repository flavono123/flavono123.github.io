<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>jq 필터로 JSON 정렬하기 | flavono123</title>
<link rel=stylesheet href=https://flavono123.github.io/assets/css/post.css>
<script defer src=https://flavono123.github.io/assets/js/lbox.js></script>
<link rel=stylesheet href=https://flavono123.github.io/assets/css/common.css>
</head>
<body>
<main>
<header>
<a class=site-title href=https://flavono123.github.io/>flavono123</a>
</header>
<section class=article>
<div class=article-header>
<h2 class=article-title>jq 필터로 JSON 정렬하기</h2>
<small class=date>Tue Mar 29, 2022</small>
<div class=tags>
<a href=https://flavono123.github.io/tags/jq class=tag>jq</a>
</div>
</div>
<div class=content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ jq --version
jq-1.6
</code></pre></div><p>jq를 써 JSON을 정렬해보자. 정렬은 키를 기준으로 한다.</p>
<p>쿠버네티스 정의 파일을 편집하면 키 순서대로 정렬되어 있는것을 볼 수 있다(보통은 JSON이 아닌 YAML로 보긴한다). 긴 파일에서 키가 정렬되어 있는 것은 한눈에 보기에 편하다. 그래서인지 언제부턴가 다음 같은 JSON은 보기 불편하다. 예시로 쓸 JSON은 짧긴 하다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;:2,&#34;a&#34;:1}&#39;</span> | jq
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;b&#34;</span>: 2,
  <span style=color:#e6db74>&#34;a&#34;</span>: <span style=color:#ae81ff>1</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=중첩-없는-json-정렬하기>중첩 없는 JSON 정렬하기</h2>
<p>키를 기준으로 정렬할 것이다. jq엔 객체(JSON)의 키를 출력하는 <code>keys</code>와 배열을 정렬하는 <code>sort</code>라는 빌트인 함수가 있다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;:2,&#34;a&#34;:1}&#39;</span> | jq <span style=color:#e6db74>&#39;keys | sort&#39;</span>
<span style=color:#f92672>[</span>
  <span style=color:#e6db74>&#34;a&#34;</span>,
  <span style=color:#e6db74>&#34;b&#34;</span>
<span style=color:#f92672>]</span>

</code></pre></div><p>하지만 정렬된 키 배열이 아니라 키 순서로 정렬된 원래의 JSON이 필요하다. 먼저 <code>to_entries</code> 라는 빌트인 함수로 JSON의 키와 값을 하나의 객체로 하는 배열을 만들어 준다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;:2,&#34;a&#34;:1}&#39;</span> | jq <span style=color:#e6db74>&#39;to_entries&#39;</span>
<span style=color:#f92672>[</span>
  <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;b&#34;</span>,
    <span style=color:#e6db74>&#34;value&#34;</span>: <span style=color:#ae81ff>2</span>
  <span style=color:#f92672>}</span>,
  <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;a&#34;</span>,
    <span style=color:#e6db74>&#34;value&#34;</span>: <span style=color:#ae81ff>1</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>]</span>
</code></pre></div><p><code>sort_by</code> 빌트인 함수 인자에 키 경로를 주어 이 배열을 정렬한다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;:2,&#34;a&#34;:1}&#39;</span> | jq <span style=color:#e6db74>&#39;to_entries | sort_by(.key)&#39;</span>
<span style=color:#f92672>[</span>
  <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;a&#34;</span>,
    <span style=color:#e6db74>&#34;value&#34;</span>: <span style=color:#ae81ff>1</span>
  <span style=color:#f92672>}</span>,
  <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;b&#34;</span>,
    <span style=color:#e6db74>&#34;value&#34;</span>: <span style=color:#ae81ff>2</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>]</span>

</code></pre></div><p>그리고 키 값 객체의 배열 즉, 엔트리 배열을 <code>from_entries</code>로 다시 객체로 만들 수 있다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;:2,&#34;a&#34;:1}&#39;</span> | jq <span style=color:#e6db74>&#39;to_entries | sort_by(.key) | from_entries&#39;</span>
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;a&#34;</span>: 1,
  <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#ae81ff>2</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>중첩이 없는, 1 계층의 JSON의 정렬은 아주 간단하다. 하지만 값에 객체가 있는 JSON의 경우 모든 JSON이 정렬되지 않는다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;: {&#34;d&#34;: 3,&#34;c&#34;: 2},&#34;a&#34;:1}&#39;</span> | jq <span style=color:#e6db74>&#39;to_entries | sort_by(.key) | from_entries&#39;</span>
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;a&#34;</span>: 1,
  <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;d&#34;</span>: 3,
    <span style=color:#e6db74>&#34;c&#34;</span>: <span style=color:#ae81ff>2</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=중첩-json-정렬하기>중첩 JSON 정렬하기</h2>
<p>맨 위에서 볼 수 있는 <code>keys</code> 뿐만 아니라, 중첩된 객체의 키도 순서대로 정렬하고 싶다. 엔트리를 순회하다가 값(<code>.value</code>)이 객체일 경우 위에서 한 정렬과 같은 동작을 재귀적으로 하고 싶다. 이를 위한 빌트인 함수 <code>walk</code>가 있다. 일단 결과를 보자:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>✦ ❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;: {&#34;d&#34;: 3,&#34;c&#34;: 2},&#34;a&#34;:1}&#39;</span> | <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> jq <span style=color:#e6db74>&#39;walk(if type==&#34;object&#34; then
</span><span style=color:#e6db74>   to_entries | sort_by(.key) | from_entries
</span><span style=color:#e6db74> else
</span><span style=color:#e6db74>   .
</span><span style=color:#e6db74> end)&#39;</span>
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;a&#34;</span>: 1,
  <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;c&#34;</span>: 2,
    <span style=color:#e6db74>&#34;d&#34;</span>: <span style=color:#ae81ff>3</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>if-else 문이 추가되긴 했지만, if 에서 실행하는 합성 함수는 위에서 쓴 JSON 정렬과 같다. if 문은 잠시 잊고, <code>walk</code> 가 하는 일을 보자:</p>
<blockquote>
<p><strong>walk(f)</strong></p>
</blockquote>
<blockquote>
<p>The walk(f) function applies f recursively to every component of the input entity. When an array is encoun-
tered, f is first applied to its elements and then to the array itself; when an object is encountered, f is
first applied to all the values and then to the object. In practice, f will usually test the type of its
input, as illustrated in the following examples. The first example highlights the usefulness of processing
the elements of an array of arrays before processing the array itself. The second example shows how all the
keys of all the objects within the input can be considered for alteration.</p>
</blockquote>
<pre><code>       jq 'walk(if type == &quot;array&quot; then sort else . end)'
          [[4, 1, 7], [8, 5, 2], [3, 6, 9]]
       =&gt; [[1,4,7],[2,5,8],[3,6,9]]

       jq 'walk( if type == &quot;object&quot; then with_entries( .key |= sub( &quot;^_+&quot;; &quot;&quot;) ) else . end )'
          [ { &quot;_a&quot;: { &quot;__b&quot;: 2 } } ]
       =&gt; [{&quot;a&quot;:{&quot;b&quot;:2}}]
</code></pre>
<p><code>walk</code>는 입력의 모든 컴포넌트에 <strong>재귀적</strong>으로 실행한다. 좀 더 자세히 설명하면, 배열의 경우 배열의 원소에 모두 함수 <code>f</code>를 실행한 후 배열 자체에 함수 <code>f</code>를 실행한다. 객체의 경우 객체 모든 값에 함수 <code>f</code>를 실행한 후 객체 자체에 함수 <code>f</code>를 실행한다.</p>
<p>아래의 두 예제 중 첫번째를 보면, 바깥 배열의 원소인 안쪽 배열이 각각 정렬되어 있고 바깥 배열(itself)도 안 배열의 가장 앞 원소에 따라 정렬되어 있다. 바깥 배열의 정렬은 순서를 조금 바꿔주면 명확하게 볼 수 있다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;[[4, 1, 7], [3, 6, 9], [8, 5, 2]]&#39;</span> | jq -c <span style=color:#e6db74>&#39;walk(if type == &#34;array&#34; then sort else . end)&#39;</span>
<span style=color:#f92672>[[</span>1,4,7<span style=color:#f92672>]</span>,<span style=color:#f92672>[</span>2,5,8<span style=color:#f92672>]</span>,<span style=color:#f92672>[</span>3,6,9<span style=color:#f92672>]]</span>
</code></pre></div><p>즉 배열 원소에 대한 <code>sort</code>의 정렬 방식은 다음과 같다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;[[2], [0], [1]]&#39;</span> | jq -c <span style=color:#e6db74>&#39;walk(if type == &#34;array&#34; then sort else . end)&#39;</span>
<span style=color:#f92672>[[</span>0<span style=color:#f92672>]</span>,<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>,<span style=color:#f92672>[</span>2<span style=color:#f92672>]]</span>

</code></pre></div><p>또 이어서 설명하듯 보통 <code>f</code> 함수는 입력의 타입을 검사하는걸로 시작하게 된다. 우리의 예제는 JSON을 정렬하는 것이라, 배열과 객체 중 객체에 대해서만 정렬(<code>to_entries | sort_by(.key) | from_entries</code>)을 할 것이라 객체 타입을 검사하는 if문을 썼다.</p>
<p>그런데 <code>walk</code>는 아주 최신 버전인, 1.6 버전의 빌트인 함수이다. 1.5 버전엔 없다. <a href=https://stedolan.github.io/jq/download/>데비안을 비롯한 리눅스 패키지와 윈도우 패키지에선 1.5 이하가 최신 버전이다(맥이라서 1.6버전을 쓸 수 있었다)</a>. 따라서 바이너리를 받아 1.6 버전을 쓰지 않는다면 <code>walk</code>를 구현해야 한다.</p>
<p><code>walk</code>의 구현은 jq의 자체의 함수 선언에서 가능하다. 다음은 <a href=https://github.com/stedolan/jq/blob/master/src/builtin.jq#L273-L280>실제 1.6 버전의 빌트인 <code>walk</code>의 구현</a>이다:</p>
<pre tabindex=0><code class=language-jq data-lang=jq>def walk(f):
  . as $in
  | if type == &quot;object&quot; then
      reduce keys_unsorted[] as $key
        ( {}; . + { ($key):  ($in[$key] | walk(f)) } ) | f
  elif type == &quot;array&quot; then map( walk(f) ) | f
  else f
  end;
</code></pre><p>앞선 매뉴얼의 설명과 일치하고 꽤 간결하다. 단순히 2 계층에 대해서가 아니라 완전히 재귀적으로 동작하는가 확인해본다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;: {&#34;d&#34;: {&#34;g&#34;: 5, &#34;f&#34;: 4, &#34;e&#34;: 3},&#34;c&#34;: 2},&#34;a&#34;:1}&#39;</span> | <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> jq <span style=color:#e6db74>&#39;walk(if type==&#34;object&#34; then
</span><span style=color:#e6db74>   to_entries | sort_by(.key) | from_entries
</span><span style=color:#e6db74> else
</span><span style=color:#e6db74>   .
</span><span style=color:#e6db74> end)&#39;</span>
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;a&#34;</span>: 1,
  <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;c&#34;</span>: 2,
    <span style=color:#e6db74>&#34;d&#34;</span>: <span style=color:#f92672>{</span>
      <span style=color:#e6db74>&#34;e&#34;</span>: 3,
      <span style=color:#e6db74>&#34;f&#34;</span>: 4,
      <span style=color:#e6db74>&#34;g&#34;</span>: <span style=color:#ae81ff>5</span>
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=옵션---sort-keys>옵션 <code>--sort-keys</code></h2>
<p>뿌듯하게 이 글을 마무리하는 중, 매뉴얼을 읽다가 간단한 옵션을 발견했다:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>❯ echo <span style=color:#e6db74>&#39;{&#34;b&#34;: {&#34;d&#34;: {&#34;g&#34;: 5, &#34;f&#34;: 4, &#34;e&#34;: 3},&#34;c&#34;: 2},&#34;a&#34;:1}&#39;</span> | <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> jq --sort-keys
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;a&#34;</span>: 1,
  <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;c&#34;</span>: 2,
    <span style=color:#e6db74>&#34;d&#34;</span>: <span style=color:#f92672>{</span>
      <span style=color:#e6db74>&#34;e&#34;</span>: 3,
      <span style=color:#e6db74>&#34;f&#34;</span>: 4,
      <span style=color:#e6db74>&#34;g&#34;</span>: <span style=color:#ae81ff>5</span>
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>그렇다. 나의 구구절절 필터는 <code>--sort-keys</code> 라는 옵션 한방으로 해결 가능하다😹&mldr;</p>
<p>&lsquo;JSON 정렬하기&rsquo;라는 목적만 보면, 앞선 필터를 만들어 내는것은 비효율적이다. 단순히 글자 수만 비교해도 그렇다. 하지만 <code>walk</code>의 동작을 이해한 것, jq 필터를 프로그래매틱하게 사용한 것이라는 수확이 있었다. jq 필터를 좀 더 잘 다룰 수 있게 됐다.</p>
<h2 id=정리>정리</h2>
<ul>
<li><code>walk</code>는 인자 함수 <code>f</code>를 재귀적으로 호출한다
<ul>
<li>배열은 각 원소에 <code>f</code> 실행 후 배열 자신에 <code>f</code> 실행하고</li>
<li>객체는 각 값에 <code>f</code> 실행 후 객체 자신에 <code>f</code>를 실행한다</li>
<li>나머지 타입은 <code>f</code> 실행만 한다</li>
</ul>
</li>
<li>JSON 키 정렬은 <code>--sort-keys</code>로 간단하게 할 수 있다
<ul>
<li><a href=https://gist.github.com/flavono123/f71903270ab6b3d9bb823ebddac702f0>필터를 활용하여 프로그래매틱하게 할 수도 있다</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id=참고>참고</h2>
<ul>
<li><a href=https://stedolan.github.io/jq/manual/v1.6/>https://stedolan.github.io/jq/manual/v1.6/</a></li>
</ul>
</div>
</section>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//flavono123.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
<footer>
<p>&copy; 2021 - 2023 </p>
</footer>
</main>
</body>
</html>