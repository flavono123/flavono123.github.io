<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on flavono123</title><link>https://flavono123.github.io/posts/</link><description>Recent content in Posts on flavono123</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 03 May 2022 09:10:13 +0900</lastBuildDate><atom:link href="https://flavono123.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Ansible 커스텀 필터 from_toml, to_toml</title><link>https://flavono123.github.io/posts/ansible-filter-plugins-from-to-toml/</link><pubDate>Tue, 03 May 2022 09:10:13 +0900</pubDate><guid>https://flavono123.github.io/posts/ansible-filter-plugins-from-to-toml/</guid><description>TOML은 YAML/JSON 보단 빈도는 적지만 설정 파일 포맷으로 쓰이는 곳이 있다. 그래서인지 Ansible에 from_yaml, to_yaml, from_json, to_json 등의 Jinja2 필터는 있지만, TOML용 필터는 없다.
쓸 일이 있기도 해서 Ansible에서 사용할 수 있는 from_toml, to_toml Jinja2 필터를 만들어 본다. 또 나는 파이썬을 잘 모르지만 필터를 작성하는데엔 무리가 없었다. 다만 같은 이유로 이 글에서 파이썬과 관련한 자세한 설명은 생략한다.
준비 빈 경로에 다음과 같은 파일을 써준다:
❯ tree . . ├── localhost └── var.</description></item><item><title>Nginx OCSP Stapling 경고 재현하기</title><link>https://flavono123.github.io/posts/ocsp-stapling/</link><pubDate>Tue, 26 Apr 2022 17:41:35 +0900</pubDate><guid>https://flavono123.github.io/posts/ocsp-stapling/</guid><description>nginx: [warn] &amp;#34;ssl_stapling&amp;#34; ignored, issuer certificate not found for certificate &amp;#34;/path/to/cert&amp;#34; TLS 인증서를 교체하고 Nginx 설정 테스트(nginx -t)를 해보았는데 위 경고가 나왔다. 테스트할 서버부터 적용했는데 인증과 파일 서빙 자체는 잘 되었다. 위 메세지로 검색하다 보니 CRL, OCSP 등의 처음 보는 개념을 알게 됐고, 로컬 Nginx에서 위와 같은 문제를 재현하고 해결할 수 있었다.
CRL 먼저 앞서 말한 CRL과 OCSP는 인증서 폐기(Certificate Revocation)에 관련한 용어이다. 보통 인증서에 문제가 있으면 새로 발급을 받더라도 이전 것이 폐기 됐는지 안했던터라 조금 생소했다.</description></item><item><title>Dockerfile Best Practices</title><link>https://flavono123.github.io/posts/dockerfile-best-practices/</link><pubDate>Tue, 19 Apr 2022 10:07:58 +0900</pubDate><guid>https://flavono123.github.io/posts/dockerfile-best-practices/</guid><description>https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
위 가이드는 CKS를 공부하던 중 multi-stage build라는 키워드로 유입됐다. 회사에서도 컨테이너라이즈를 하는 중이라 한번 읽고 정리하며 몇가지 실험을 해봤다(그리고 후술하지만, 이 문서를 포함해 도커 문서는 최신화가 덜 되어 있다. 다른 레퍼런스나 질문도 그리고 직접 실험하는 것도 활용해보자)
Dockerfile은 도커 이미지를 만드는 명령을 써 놓은 파일이다. Dockerfile을 잘 쓰는 것은 &amp;lsquo;어떻게 좋은 도커 이미지를 만들 것인가&amp;rsquo;에 대한 답이다. 좋은 도커 이미지란 가능한 작은 크기의 이미지를 말한다. 작은 이미지는 다음과 같은 이점이 있다:</description></item><item><title>jq 커스텀 함수 라이브러리화</title><link>https://flavono123.github.io/posts/jq-library/</link><pubDate>Thu, 31 Mar 2022 17:57:16 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-library/</guid><description>이전 글 &amp;ldquo;jq 커스텀 함수 사용(Elasticsearch 프로퍼티 매핑 JSON 만들기)&amp;quot;에서 좀 불편한 점이 있다. -f 옵션을 단 하나만 쓰기 때문에 인자인 필터 파일 하나에 아주 작은 수정도 입력해야 한다. 실제로 &amp;ldquo;e&amp;rdquo; 경로를 보기 위해 | .e를 파일에 써 주었다. 길고 복잡해진 필터를 파일에 썼지만, 명령줄에서 파이프(합성)하여 쓰는 이점이 사라졌다.
이런 문제점을 해결하기 위해jq는 라이브러리(모듈) 기능을 제공한다.
&amp;ldquo;jq 필터로 JSON 정렬하기&amp;rdquo;에서 예로 든 JSON 정렬 필터를 예시로 들어 본다. 먼저 작업 디렉토리에 jqlib 라는 디렉토리를 만들고 아래 .</description></item><item><title>jq 커스텀 함수 사용(Elasticsearch 프로퍼티 매핑 JSON 만들기)</title><link>https://flavono123.github.io/posts/jq-custom-function/</link><pubDate>Wed, 30 Mar 2022 08:07:45 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-custom-function/</guid><description>Elasticsearch의 인덱스된 문서 필드에 데이터 타입이 동적으로 매핑이 된다. 하지만 인덱스 크기를 제한하기 위해 회사에선 명시적 매핑을 사용하고 있다.
그리고 회사에서 ES는 대부분 로그를 검색하는 용도로 쓰기 위해 사용하고 있다. 즉, ES 문서가 로그이다. 로그는 대부분 JSON이다. 그리고 매핑의 바디 역시 JSON이다. 따라서 내가 만들려는 것은 다음 같은 JSON 입출력의 jq 필터이다:
# 입력 ❯ cat input.json | jq { &amp;#34;a&amp;#34;: 11, &amp;#34;b&amp;#34;: 0.1 } # 출력 ❯ cat output.json | jq { &amp;#34;a&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;integer&amp;#34; }, &amp;#34;b&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;float&amp;#34; } } ES 매핑의 문법을 자세히 모르더라도 이해할 수 있도록 예시 JSON을 구성했다.</description></item><item><title>jq 필터로 JSON 정렬하기</title><link>https://flavono123.github.io/posts/jq-sort-json/</link><pubDate>Tue, 29 Mar 2022 20:16:40 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-sort-json/</guid><description>❯ jq --version jq-1.6 jq를 써 JSON을 정렬해보자. 정렬은 키를 기준으로 한다.
쿠버네티스 정의 파일을 편집하면 키 순서대로 정렬되어 있는것을 볼 수 있다(보통은 JSON이 아닌 YAML로 보긴한다). 긴 파일에서 키가 정렬되어 있는 것은 한눈에 보기에 편하다. 그래서인지 언제부턴가 다음 같은 JSON은 보기 불편하다. 예시로 쓸 JSON은 짧긴 하다:
❯ echo &amp;#39;{&amp;#34;b&amp;#34;:2,&amp;#34;a&amp;#34;:1}&amp;#39; | jq { &amp;#34;b&amp;#34;: 2, &amp;#34;a&amp;#34;: 1 } 중첩 없는 JSON 정렬하기 키를 기준으로 정렬할 것이다. jq엔 객체(JSON)의 키를 출력하는 keys와 배열을 정렬하는 sort라는 빌트인 함수가 있다:</description></item><item><title>Stow로 dofiles 관리하기</title><link>https://flavono123.github.io/posts/stow-dofiles/</link><pubDate>Sat, 26 Mar 2022 00:10:53 +0900</pubDate><guid>https://flavono123.github.io/posts/stow-dofiles/</guid><description>과거엔 dotfiles를 Git bare repositoy로 관리했다. 아니 관리에 실패했다. 노트북을 바꾸진 않았지만 어떤 이유로(기억이 안난다) 싹 초기화 했는데 다시 bare repo를 만들고 사용하질 않았다(개발에 관심을 덜 가졌던 시기라서도 그렇다).
최근 사용하는 쉘, 에디터, 도구들을 손보면서 dotfiles도 자주 수정하게 됐다. 싱크가 안된, 아카이브와도 같은 dotfiles 레포와 실제 dotfiles를 관리하는게 점점 부담으로 다가왔다.
다시 bare repo 사용법을 익히려 검색을 하던 중 stow라는 프로그램을 사용하면 다른 방법으로, 쉽게 dotfiles를 관리할 수 있다는걸 알게 됐다.</description></item><item><title>여러 호스트에 간단한 명령하기(Ansible vs. PSSH)</title><link>https://flavono123.github.io/posts/ansible-pssh/</link><pubDate>Thu, 24 Mar 2022 11:46:14 +0900</pubDate><guid>https://flavono123.github.io/posts/ansible-pssh/</guid><description>이 글은 프로비저닝 툴로써 Ansible과 PSSH를 비교하는 글이 아니다. 간단한 명령을 할 때 Ansible과 PSSH 둘 다 사용해보고 비교하는 글이다.
나는 프로비저닝 툴로썬 Ansible을 이미 쓰고 있는데, 막상 간단한 명령을 하려니 &amp;ldquo;PSSH를 쓰는게 더 쉬운가?&amp;rdquo; 라는 생각이 들었다. 상황은 간단하게 각 호스트의 공인 IP를 알아내는 것이다. 각 호스트에서 curl ifconfig.me 를 실행하고 출력을 확인해야 한다.
PSSH ❯ pssh --version 2.3.1 호스트 인자로 인벤토리 파일 활용 앞서 말한 듯 Ansible을 사용하고 있는 상황이기 때문에 PSSH의 호스트 인자로 Ansible의 인벤토리 INI 파일을 쓸 것이다.</description></item><item><title>맥에서 GNU 프로그램 사용</title><link>https://flavono123.github.io/posts/gnubin-in-macos/</link><pubDate>Tue, 15 Mar 2022 23:53:09 +0900</pubDate><guid>https://flavono123.github.io/posts/gnubin-in-macos/</guid><description>맥에 기본으로 설치된 CLI 프로그램은 BSD의 것이다. 그런데 그런 프로그램들 사용법을 알기 위해 검색하면 대부분 Linux에 설치된 GNU 프로그램 기준으로 설명하는 경우가 많다. 심지어 ls 도 옵션 사용이 조금 다르다(e.g. -w 옵션의 의미가 다르다):
https://www.freebsd.org/cgi/man.cgi?ls https://man7.org/linux/man-pages/man1/ls.1.html 이 때문에 맥에서 참고한 같은 명령을 치고 결과가 다르거나 오류가 발생하는 경우가 꽤 있다. 따라서 맥에서도 GNU 프로그램을 사용하는게 속편한것 같다.
GNU 프로그램은 brew를 통해 받을 수 있다:
brew install autoconf bash binutils coreutils diffutils ed findutils flex gawk \ gnu-indent gnu-sed gnu-tar gnu-which gpatch grep gzip less m4 make nano \ screen watch wdiff wget 이를 기본 프로그램으로 사용하기 위해 PATH 변수 앞에 붙여 준다.</description></item><item><title>Ansible로 모든 VM을 SSH 연결하기</title><link>https://flavono123.github.io/posts/ansible-ssh-keygen/</link><pubDate>Tue, 08 Mar 2022 23:27:10 +0900</pubDate><guid>https://flavono123.github.io/posts/ansible-ssh-keygen/</guid><description>언제나 그렇듯 삽질 후 깔끔하게 정리한다. VM끼리 ssh로 연결하고 싶었다. 보통은 쉘 스크립트로 프로비저닝했다. 그런데 ansible로 해보니 몇가지 어려운 점이 있었다:
authorized_keys를 만들 때 각 VM에서 만든 공개키를 &amp;lsquo;모아야&amp;rsquo; 한다. SSH key를 &amp;lsquo;새로 만든 VM만&amp;rsquo; authorized_keys를 갱신해야 한다. SSH key gen은 Self-signed Certificate을 해보며 잘 이해해서 ansible-galaxy에 있는 community.crypto.openssh_keypair로 대체했다.
Special varibables VM을 up하고 아무도 SSH 키 쌍이 없는 상태에선 모두 키를 만들고 공개키를 모아서 모두의 authorized_keys 파일에 써주어야 한다.</description></item><item><title>Vagrant byebug로 디버깅하기</title><link>https://flavono123.github.io/posts/byebug-vagrant/</link><pubDate>Mon, 07 Mar 2022 00:38:49 +0900</pubDate><guid>https://flavono123.github.io/posts/byebug-vagrant/</guid><description>Vagrant를 쓰던 중 byebug로 breakpoint를 잡고 디버깅 해보고 싶어졌다. 이 글을 참고했으나, 난 pry, pry-byebug가 아닌 byebug를 사용했다(과거엔 저렇게 썼다고 들었다). 또 글과 달리, (이젠) 맥에서 brew로 설치한 vagrant는 소스 코드를 받아 실행하지 않는걸로 보인다.
먼저 원래 쓰고 있던 brew로 설치한 vagrant를 지운다:
❯ brew uninstall vagrant 문서대로 vagrant를 코드를 받아 설치한다:
❯ git clone https://github.com/hashicorp/vagrant.git ❯ cd vagrant ❯ bundle install ❯ bundle --binstubs exec # Deprecation warning ❯ cd /usr/local/bin/ ❯ ln -sf /path/to/vagrant/exec/vagrant bundle --binstubs exec을 실행하면 deprecation warning이 나올 것이다.</description></item><item><title>ip: 리눅스 네트워크 장치</title><link>https://flavono123.github.io/posts/get-net-dev-from-ip/</link><pubDate>Sun, 06 Mar 2022 00:03:41 +0900</pubDate><guid>https://flavono123.github.io/posts/get-net-dev-from-ip/</guid><description>리눅스에서 ip 명령을 통해 네트워크 장치를 확인하고 구성할 수 있다. 그런데 이더넷 카드 이름이 언젠가부터(?) eth*가 아닌 enp*s*로 나오고 있다. &amp;lsquo;언젠가&amp;rsquo;는 리눅스를 VMWare에 처음 설치해봤던 학생 때이고 지금은 시간이 많이 지났다. eth는 이더넷이란 이름에 찰싹 달라 붙어 받아 들였지만, eno* 또는 enp*s* 역시 이더넷 카드를 뜻하는건지 궁금해졌다. 이번에도 알게 된 점 그리고 모르기로 한 부분을 나눠 정리한다.
Predictable Network Interface Names 위 같은 변화는 systemd가 나오며 시작됐다(정확하게는 v197라는 배포판에서 이다). 과거엔 간단하게 eth 뒤에 인덱스를 붙여도 드라이버가 찾을 수 있었지만, 오늘 날의 네트워크 구성 기술에선 이름을 쉽게 바꿀 수 있고 같은 이름으로도 여러 곳에서 사용할 수 있어 적합하지 않다고 한다.</description></item><item><title>NetworkPolicy 설정 시 주의점</title><link>https://flavono123.github.io/posts/notes-for-netpol/</link><pubDate>Fri, 04 Mar 2022 20:57:52 +0900</pubDate><guid>https://flavono123.github.io/posts/notes-for-netpol/</guid><description>CKAD killer.sh 시뮬레이터를 풀다가, 배점이 가장 높은 문제에서 계속 틀렸다. 이번에도 네트워크 정책 문제였다. 이번에도 몇가지 실험해서 알게 된 점을 정리한다.
문제에서 egress 설정을 잘한거 같은데 안됐다. 예를 들면 1234로 서비스 노출한 특정 파드(nginx)에 특정 파드만(san) 접근할 수 있게 하는 것이다:
❯ k -n netpol-test run nginx --image=nginx --port 80 pod/nginx created ❯ k -n netpol-test expose po nginx --port=1234 --target-port=80 service/nginx exposed apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: san-to-nginx namespace: netpol-test spec: podSelector: matchLabels: run: san policyTypes: - Egress egress: - to: - podSelector: matchLabels: run: nginx ports: - protocol: TCP port: 1234 ❯ k -n netpol-test run san --rm -i --image=busybox --restart=Never -- nc -zv -w 3 nginx 1234 If you don&amp;#39;t see a command prompt, try pressing enter.</description></item><item><title>nc(Netcat)으로 NetworkPolicy 디버깅</title><link>https://flavono123.github.io/posts/debug-netpol-with-nc/</link><pubDate>Thu, 03 Mar 2022 20:30:09 +0900</pubDate><guid>https://flavono123.github.io/posts/debug-netpol-with-nc/</guid><description>CKAD 문제를 풀던 중 네트워크 정책을 설정하고 검증해야하는 문제가 있었는데 telnet 명령이 들질 않았다:
root@controlplane:~# k exec &amp;lt;from-pod&amp;gt; -- telnet &amp;lt;svc&amp;gt; 80 OCI runtime exec failed: exec failed: container_linux.go:367: starting container process caused: exec: &amp;#34;telnet&amp;#34;: executable file not found in $PATH: unknown command terminated with exit code 126 답지에선 nc(Netcat)을 사용해서 검증했다. nc라는 명령을 처음 알게 됐다. 문제를 재구성 해봤고 그 과정에서 알게 된 사실을 공유한다.
nc 앞서 말한 nc는 telnet과 비슷하게 호스트의 포트가 열려 있는지 간단하게 확인 가능하다.</description></item><item><title>Terraform으로 AWS 로그인 자격 증명 생성 시 PGP 키 사용</title><link>https://flavono123.github.io/posts/aws_iam_user_login_profile_pgp_key/</link><pubDate>Tue, 01 Mar 2022 16:51:33 +0900</pubDate><guid>https://flavono123.github.io/posts/aws_iam_user_login_profile_pgp_key/</guid><description>회사 AWS IAM를 테라포밍하고 있다. 계기가 되는 사건이 하나 있는데, 내가 devops니까, 다른 팀에서 AWS에 특정 권한이 있는 계정을 생성해달라는 요구를 받았다. 난 우리가 AWS를 거의 안 쓰고 내가 로그인하는 루트 계정도 공용 계정이라 따로 IAM 관리를 아예 안하는 줄 알았다. 하지만 그렇지 않았다&amp;hellip; 적어도 코드로 리뷰하고 공유하면 이런 지식이 단절 되는 일은 없을거 같아 (방치해둔) terraform을 쓰자고 했다.
그렇게 최소한의 권한만 허가하며 terraform으로 만들어 가던 중, 요청한 팀에서 콘솔 로그인도 필요하다고 했다.</description></item><item><title>CKA 시험 후기와 Security Context - 리눅스 네임스페이스, capabilities</title><link>https://flavono123.github.io/posts/cka-security-context/</link><pubDate>Fri, 25 Feb 2022 18:24:34 +0900</pubDate><guid>https://flavono123.github.io/posts/cka-security-context/</guid><description>이전까지 쓰던 CKA 강의 정리 글을 중단하고, 남은 섹션 빠르게 공부한 후, 합격했다&amp;hellip;
인터넷에 보면 시험 (합격)후기 글이 많다. 시험 팁과 관련된 내용이 주로 있고 나도 그런 글 도움을 많이 받았다. 하지만 나는 조금 다른 이야길 해보려 한다.
우선 강의와 더불어 시험을 보는 과정에서 배우는 것들이 좋았다. 어찌보면 난 컨테이너(도커)는 아주 깔짝, 리눅스도 깔짝 알고 있는 수준이었다는게 드러났다. 예컨데 나는 리눅스 네트워크는 꽤 잘 안다고 착각했다. 이유는 (지금 생각하면 조금 어이 없지만) on-premise 호스트에서 DHCP를 쓰지 않고 정적으로 IP를 할당했기 때문에 그렇다고 생각했다.</description></item><item><title>nginx location 점프</title><link>https://flavono123.github.io/posts/nginx-location-jump/</link><pubDate>Fri, 25 Feb 2022 12:33:29 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-location-jump/</guid><description>지난 포스트, nginx 블록 선택 알고리즘, 에서 테스트와 설명에 자신감이 없던 부분에 대한 보충 설명이다. Understanding Nginx Server and Location Block Selection Algorithms를 참고하여 location 컨텍스트 내에서 다시 location 탐색을 유발하는 디렉티브 네개를 소개했다:
index try_files rewrite error_page 이 중 세개는 테스트해봤다. 첫번째인 index 디렉티브는 검증하지 못했다. 디지털 오션 참고 글엔 location 컨텍스트가 비어 있어, index 디렉티브를 상속 받는게 아니라 각각 써주었다:
... location = /exact { index index.</description></item><item><title>MongoDB 모니터가 빠진 건에 대하여</title><link>https://flavono123.github.io/posts/mongodb-monitor/</link><pubDate>Wed, 23 Feb 2022 22:50:45 +0900</pubDate><guid>https://flavono123.github.io/posts/mongodb-monitor/</guid><description>어느 날, MongoDB 서버에서 CPU 사용율이 높다는 알람이 왔다. CPU 사용율은 금방 정상을 돌아왔지만, pmm-client가 설치되지 않아서 쿼리를 특정할 수 없었다. pmm-client는 MongoDB 각 멤버가 재시작 되면서(한때 장애로 failover를 밥 먹듯이 했다&amp;hellip;) server로부터 떨어진거 같았다. 최근엔 재시작 되는 일 없이 안정적으로 서비스 실행 중이라 다시 붙이기로 했다. 그리고 그 사이에 클러스터에 변화도 생겼는데 이것도 반영했다.
클러스터 구성 현재 클러스터 구성은 다음과 같다:
host1 host2 host3 host4 host5 host6 replicaset1 replicaset1 replicaset1 replicaset2 replicaset2 replicaset2 config config config router router router router router router 총 6대의 호스트에 설치되어 있다.</description></item><item><title>nginx 블록 선택 알고리즘</title><link>https://flavono123.github.io/posts/nginx-block-selection/</link><pubDate>Sat, 19 Feb 2022 17:07:52 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-block-selection/</guid><description>지난 포스트 웹 서버/리버스 프록시로서 nginx 설정 구조(HTTP)와 nginx 설정 정적 분석에서 이어지는 내용이다.
nginx 설정은 server와 location 디렉티브를 정의하여 요청이 어떻게 처리할지 정하게 된다. 이 글은 Understanding Nginx Server and Location Block Selection Algorithms를 읽고 이해한 일부 내용을 정리한다(다 이해하진 못했는데 이 부분은 나중에 설정을 바꿔가며 직접 테스트 해보는걸로 미뤄둔다..).
server 블록 선택 알고리즘 server 블록은 요청에서 IP와 포트 그리고 Host 헤더 관련한 부분을 필터하여 가상 서버를 선택한다.
listen 먼저 listen 디렉티브 인자로 매치할 IP와 포트를 정의한다(소켓 경로도 인자로 받을 수 있으나 여기서 다루진 않는다).</description></item><item><title>맥에서 kubectl bash 자동 완성 기능 켜기</title><link>https://flavono123.github.io/posts/kubectl-bash-auto-completion-in-mac/</link><pubDate>Thu, 17 Feb 2022 16:06:33 +0900</pubDate><guid>https://flavono123.github.io/posts/kubectl-bash-auto-completion-in-mac/</guid><description>쿠버네티스 문서 bash 자동완성 안내처럼 $HOME/.bash_profile에 코드를 추가했는데, 자동완성이 되질 않는다:
❯ tail -3 ~/.bash_profile source &amp;lt;(kubectl completion bash) alias k=kubectl complete -F __start_kubectl k ❯ k ap-bash: completion: function `__start_kubectl&amp;#39; not found # k apply 치고 싶어! 구글링 결과 다른 문서를 찾게 됐다. 안되는 이유는 맥 시스템의 기본 bash 버전에선 자동완성이 지원되지 않기 때문이다.
아마 위와 같은 문제를 겪고 있다면 bash 버전은 4.1 미만, 맥 시스템 bash(/bin/bash)를 쓰고 있을 감능성이 높다:</description></item><item><title>MariaDB semi-join과 구체화 뷰</title><link>https://flavono123.github.io/posts/mariadb-semi-join/</link><pubDate>Wed, 16 Feb 2022 17:39:28 +0900</pubDate><guid>https://flavono123.github.io/posts/mariadb-semi-join/</guid><description>MariaDB Knowledge Base 다음 두 포스트를 따라하며 semi-join과 구체화 뷰 대해 이해한 점을 정리한다:
https://mariadb.com/kb/en/semi-join-subquery-optimizations/ https://mariadb.com/kb/en/semi-join-materialization-strategy/ 한번씩 읽어야 이 글도 이해가 빠를것 같다.
원랜 회사에서 겪은 DB 이슈를 공유하고 싶었는데, 한번에 글로 정리가 안되어 쪼개어 쓴다(DB 이슈는 이 글을 참고해서 이어서 쓸 예정이다).
준비 우선 Homebrew로 받은 MariaDB 10.3.32에서 테스트했다:
❯ mysql --version mysql Ver 15.1 Distrib 10.3.32-MariaDB, for osx10.16 (x86_64) using readline 5.1 MariaDB Knowlege Base(kb)의 쿼리를 따라하기 위해 샘플 데이터를 받는다.</description></item><item><title>nginx 설정 정적 분석</title><link>https://flavono123.github.io/posts/static-analysis-nginx-conf/</link><pubDate>Mon, 14 Feb 2022 19:13:48 +0900</pubDate><guid>https://flavono123.github.io/posts/static-analysis-nginx-conf/</guid><description>회사에선 nginx를 웹 서버이자 리버스 프록시로 여러군데서 쓰고 있다. 설정 파일을 레일즈 배포 시 ERB로 템플릿하고 있다. 그래서 설정 내용이 레일즈 앱에 종속적이기도 하고(배포 변수가 레일즈 앱에 연관이 있을 시), 엄청 길다.
이걸 간편하게 바꿀 임무가 주어졌다. 2000줄이 넘는 설정 파일이라 단순히 눈으로 보며 고치긴 어려울거 같아, 구조를 파싱한 후 정적으로 분석해보기로 했다.
crossplane 먼저 nginx 설정 파일을 구조를 파싱할 수 있는 도구가 있을거 같아 찾아봤다. crossplane이라는 NGINX, Inc.에서 파이썬으로 만든 도구가 있다.</description></item><item><title>웹 서버/리버스 프록시로서 nginx 설정 구조(HTTP)</title><link>https://flavono123.github.io/posts/nginx-conf-structure/</link><pubDate>Mon, 14 Feb 2022 13:12:46 +0900</pubDate><guid>https://flavono123.github.io/posts/nginx-conf-structure/</guid><description>nginx 설정을 바꾸고 재적용(reload) 전 테스트 시 오류를 본적이 있다:
$ sudo nginx -t -c /path/to/nginx.conf nginx: [emerg] &amp;#34;upstream&amp;#34; directive is not allowed here in /path/to/nginx.conf:6 upstream 디렉티브는 원래부터 저 위치에 있었고, 다른 컨텍스트 내부를 수정한거라 원인이 뭔지 몰랐다. 과거에 이렇게 잘 몰랐다가 nginx 설정을 파싱할 일이 있어 해보았는데 같은 에러를 만났다. 따라서, 제대로 공부한적 없는, nginx 설정에 대해 한번 정리해본다(디렉티브 및 컨텍스트는 회사에서 쓰고 있는 것만 정리했다).
기본 설정 파일 nginx는 설정을 읽어 오는 기본 파일 경로가 있다:</description></item><item><title>jq descendants</title><link>https://flavono123.github.io/posts/jq-descendants/</link><pubDate>Mon, 14 Feb 2022 12:08:56 +0900</pubDate><guid>https://flavono123.github.io/posts/jq-descendants/</guid><description>JSON을 다루다 보면 객체가 중첩(nested), 재귀적인(recursive) 구조가 있다. 객체 안엔 자식 객체를 담는 배열 애트리뷰트가 있고, 그 배열이 비어 있거나 또는 애트리뷰트(= 키 자체)가 없는 경우까지 반복 된다:
{ &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val2&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val4&amp;#34;, &amp;#34;children&amp;#34;: [ { &amp;#34;key1&amp;#34;: &amp;#34;target&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val6&amp;#34;, &amp;#34;children&amp;#34;: [], &amp;#34;__comment&amp;#34;: &amp;#34;더 이상 children이 없거나&amp;#34; }, { &amp;#34;key1&amp;#34;: &amp;#34;val7&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val8&amp;#34; &amp;#34;__comment&amp;#34;: &amp;#34;아예 children 키가 없다&amp;#34; }, ] }, { &amp;#34;key1&amp;#34;: &amp;#34;val9&amp;#34;, &amp;#34;key2&amp;#34;: &amp;#34;val10&amp;#34; }, ] } 이 때 특정 조건을 만족하는 객체만 필터해야 할 때가 있다.</description></item><item><title>Self-signed Certificate(NGINX)</title><link>https://flavono123.github.io/posts/self-signed-certificate/</link><pubDate>Sat, 05 Feb 2022 13:25:51 +0900</pubDate><guid>https://flavono123.github.io/posts/self-signed-certificate/</guid><description>0. 준비 openssl3 kubernetes(minikube) 1. CA RSA 키 페어 생성 실제 CA가 아니라 우리가 직접 CA를 만들어 TLS 인증하는 과정을 모의로 해본다(self-signed certificate)
$ openssl genrsa -aes256 -out rootCA.key 2048 Enter PEM pass phrase: Verifying - Enter PEM pass phrase: $ ll rootCA.key -rw------- 1 hansuk staff 1874 Jan 14 14:30 rootCA.key 비밀키 분실을 대비하여 AES256으로 암호화 한다. 이때 passphrase를 잘 기억하고 발급할 때 사용하자 2. CA 인증서 발급 $ openssl req -x509 -new -nodes -key rootCA.</description></item><item><title>CKA with Practice Tests: Logging &amp; Monitoring(+ Prometheus, Grafana)</title><link>https://flavono123.github.io/posts/cka-4-logging-monitoring/</link><pubDate>Tue, 25 Jan 2022 17:33:38 +0900</pubDate><guid>https://flavono123.github.io/posts/cka-4-logging-monitoring/</guid><description>클러스터 컴포넌트 모니터 모니터 대상은 크게 노드와 파드 두개로 나뉜다. 기본적인 메트릭 API 있다. 이를 집계하려면 별도의 메트릭 서버가 필요하다.
먼저 로컬에 구성한 minikube의 경우 metrics-server를 애드온으로 추가하면 kubectl top 명령으로 CPU와 메모리 사용량을 알 수 있다.
❯ minikube version minikube version: v1.24.0 commit: 76b94fb3c4e8ac5062daf70d60cf03ddcc0a741b ❯ minikube addons enable metrics-server ▪ Using image k8s.gcr.io/metrics-server/metrics-server:v0.4.2 🌟 &amp;#39;metrics-server&amp;#39; 애드온이 활성화되었습니다 ❯ minikube addons list |-----------------------------|----------|--------------|-----------------------| | ADDON NAME | PROFILE | STATUS | MAINTAINER | |-----------------------------|----------|--------------|-----------------------| | ambassador | minikube | disabled | unknown (third-party) | | auto-pause | minikube | disabled | google | | csi-hostpath-driver | minikube | disabled | kubernetes | | dashboard | minikube | disabled | kubernetes | | default-storageclass | minikube | enabled ✅ | kubernetes | | efk | minikube | disabled | unknown (third-party) | | freshpod | minikube | disabled | google | | gcp-auth | minikube | disabled | google | | gvisor | minikube | disabled | google | | helm-tiller | minikube | disabled | unknown (third-party) | | ingress | minikube | disabled | unknown (third-party) | | ingress-dns | minikube | disabled | unknown (third-party) | | istio | minikube | disabled | unknown (third-party) | | istio-provisioner | minikube | disabled | unknown (third-party) | | kubevirt | minikube | disabled | unknown (third-party) | | logviewer | minikube | disabled | google | | metallb | minikube | disabled | unknown (third-party) | | metrics-server | minikube | enabled ✅ | kubernetes | | nvidia-driver-installer | minikube | disabled | google | | nvidia-gpu-device-plugin | minikube | disabled | unknown (third-party) | | olm | minikube | disabled | unknown (third-party) | | pod-security-policy | minikube | disabled | unknown (third-party) | | portainer | minikube | disabled | portainer.</description></item><item><title>CKA with Practice Tests 정리: Scheduler</title><link>https://flavono123.github.io/posts/cka-3-scheduler/</link><pubDate>Sun, 23 Jan 2022 13:21:29 +0900</pubDate><guid>https://flavono123.github.io/posts/cka-3-scheduler/</guid><description>Manage scheduling 스케줄러는 파드를 어떤 노드에 할당(bind)할지 판단한다. 지금까지 파드 생성 시 정의에 명시하지 않았지만, spec.nodeName에 할당할 파드를 명시할 수 있다. 이런 방법은 추천하지 않는것 같고, 스케줄러에게 맡기되 그걸 제어할 수 있는 방법을 이번 장에서 다룬다.
스케줄러는 core Binding API(target.kind: Node)를 이용해 특정 노드에 파드 할당을 요청한다.
스케줄러는 컨트롤플레인 노드에서, 뒤에서 설명할, 스태틱 파드로 실행중이다:
❯ kubectl describe po kube-scheduler-minikube -n kube-system | grep Controlled Controlled By: Node/minikube 레이블 &amp;amp; 셀렉터 레이블: 쿠버네티스 오브젝트를 특정하기 위한 태그.</description></item><item><title>Elasticsearch를 공부하고 DDIA를 다시 읽어보았다</title><link>https://flavono123.github.io/posts/elasticsearch-and-ddia/</link><pubDate>Fri, 21 Jan 2022 15:43:56 +0900</pubDate><guid>https://flavono123.github.io/posts/elasticsearch-and-ddia/</guid><description>사내에서 Elasticsearch 스터디를 진행 중이다. 특히 키바나(쿼리와 시각화)를 더 잘 쓰고 싶어서 이 주제를 하자고 주장했다. 그런데 우리가 스터디 하는 2~3개월 정도 기간에 가이드가 될만한 책이나 강의가 마땅치 않아, 스터디 진행 구성도 오밀조밀하게 직접했다. 그중 첫단계는 Elastic 가이드 북을 한번 읽는 것인데 이제 막 끝났다.
일단 너무 재밌었다. 내가 알고 싶었던 것은, match 쿼리 결과가 왜 생각하는대로 안나오는지, terms aggregation에 왜 이런 결과가 있는지, 같은 것인데 이를 다 해소할 수 있었다.</description></item><item><title>CKA with Practice Tests 정리: Core Concepts</title><link>https://flavono123.github.io/posts/cka-2-core-concept/</link><pubDate>Sat, 15 Jan 2022 17:09:34 +0900</pubDate><guid>https://flavono123.github.io/posts/cka-2-core-concept/</guid><description>쿠버네티스에 대한 관심이 생기며 CKA란 자격증도 알게 됐다. 원랜 개발 관련한 자격증은 막연한 편견이 있었다. 실무와 거리가 멀것만 같은&amp;hellip; 하지만 시험이 프롬프트를 통해 쿠버네티스 상태를 만든다는 점에서 그런 편견이 깨졌다. 무엇보다 회사에서 아직 쿠버네티스를 쓰지 않으니 배울 수 있는 좋은 기회인거 같아 자격증 준비를 시작했다.
아주 유명한 Udemy 강의인 Certified Kubernetes Administrator (CKA) with Practice Tests를 듣고 있다. 강의를 들은 후 섹션별로 내용을 정리할 계획이다.
쿠버네티스 문서화가 잘 되어 있고 한글 번역된것도 많다.</description></item><item><title>SSL/TLS 인증서 동작 이해하기 1</title><link>https://flavono123.github.io/posts/understand-tls-certificate-with-hand-on-practice-1/</link><pubDate>Wed, 12 Jan 2022 23:21:42 +0900</pubDate><guid>https://flavono123.github.io/posts/understand-tls-certificate-with-hand-on-practice-1/</guid><description>작년에 회사에서 SSL/TLS 인증서 갱신 작업을 했다. 회사가 합병과 이사를 해서 정보가 바뀌어 CSR 생성부터 모든 과정을 했다. 당시엔 연마다 반복해야하는 작업이니 절차를 매뉴얼화 했다. 실제로 권한이 있고 명령어 복붙하면 비개발자 또는 웹 통신과 보안에 이해가 전혀 없는 사람도 할 수 있을 정도로 만들었다.
올해 다시 인증서 갱신하려 보니 내가 그런 사람인거 같았다. 실제로 인증서의 암호화나 인증 과정을 정확히 몰랐다. 따라서 SSL/TLS 인증과 관련한 키워드 검색해서 공부했다. 하지만 내가 단번에 이해할 수 있는 글은 없었다(물론 크게 도움이 된 글도 있다).</description></item><item><title>Minikube에서 NodePort 서비스 로컬 프라이빗 IP 찾기</title><link>https://flavono123.github.io/posts/minikube-service-private-ip/</link><pubDate>Fri, 07 Jan 2022 10:44:54 +0900</pubDate><guid>https://flavono123.github.io/posts/minikube-service-private-ip/</guid><description>minikube service --url &amp;lt;service-name&amp;gt; NodePort 서비스를 만들어 포트는 노출시켰는데 어느 IP로 접속할지 몰라 한참을 헤맸다&amp;hellip;
출처: https://minikube.sigs.k8s.io/docs/handbook/accessing/#getting-the-nodeport-using-the-service-command</description></item><item><title>Datadog의 이상치 감지 알고리즘: DBSCAN과 MAD</title><link>https://flavono123.github.io/posts/outlier-detection-dbscan-mad/</link><pubDate>Wed, 05 Jan 2022 22:39:59 +0900</pubDate><guid>https://flavono123.github.io/posts/outlier-detection-dbscan-mad/</guid><description>https://docs.datadoghq.com/monitors/create/types/outlier/?tab=dbscan
Datadog 모니터에선 기본적으로 한계치 알람(threshold alerts) 기능이 있다. 하지만 다음과 같은 시계열(timeserires) 그래프의 패턴은 알람의 기준을 threshold로 정할 수 없다:
스파이크나 아발란체를 예상할 수 있다. 예를 들어 밤 같은 특정 시간대에만 스루풋이 높아져 스파이크가 생긴다면 이는 알람으로 받고 싶지 않다. 값의 기준선이 요동친다(fluctuate). 물론 두번째의 경우 threshold 최소, 최대치를 높이는 방법도 생각할 수 있다. 대신 클러스터링 알고리즘과 통계적인 방법으로 이상치를 감지할 수 있다. DBSCAN DBSCAN(Density-Based Spatial Clustering of Appplication with Noise)은 클러스터링 알고리즘이다.</description></item><item><title>Minikube로 Docker Desktop를 대체해보며 쿠버네티스 통빡으로 맞춰보기</title><link>https://flavono123.github.io/posts/minikube-replace-docker-desktop/</link><pubDate>Tue, 04 Jan 2022 00:51:44 +0900</pubDate><guid>https://flavono123.github.io/posts/minikube-replace-docker-desktop/</guid><description>https://novemberde.github.io/post/2021/09/02/podman-minikube/
이 글을 읽고 회사 개발 계정 메일로 오던 도커에서 프로모 코드 뿌리는, 확인 안하던, 메일들이 생각났다.
역시 도커 데스크탑이 유료로 바뀌니 주는 할인 코드였고 마침 쿠버네티스에 대한 관심도가 마구마구 오르는 시기라 호기롭게 위 포스팅을 따라하였다.
도커 데스크탑을 삭제하고 minikube 와 kompose 설치, 기존 docker-compose 파일을 변환해서 apply 까지 마쳤다. 마침 대상으로 해본 docker-compose 의 이미지들은 어차피 로컬(맥)에선 잘 안도는거라, 컨테이너가 잘 띄워졌는지 확인하진 않았다(솔직히 쿠버네티스도 컨테이너를 띄우는가? 도커를 대체한다니깐 그러지 않을까?</description></item><item><title>카프카 컨슈머 메트릭 수집 이란 글을 쓴 후</title><link>https://flavono123.github.io/posts/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EB%A9%94%ED%8A%B8%EB%A6%AD-%EC%88%98%EC%A7%91-%EC%9D%B4%EB%9E%80-%EA%B8%80%EC%9D%84-%EC%93%B4-%ED%9B%84/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://flavono123.github.io/posts/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EB%A9%94%ED%8A%B8%EB%A6%AD-%EC%88%98%EC%A7%91-%EC%9D%B4%EB%9E%80-%EA%B8%80%EC%9D%84-%EC%93%B4-%ED%9B%84/</guid><description>https://crema.github.io/2021/06/29/collect-kafka-consumer-metrics.html
이런 글을 썼었다.
글을 쓰는덴, 위 링크 본문에도 참조되어 있는
https://www.theteams.kr/teams/865/post/64574
이 글이 많이 동기가 되었다.
글을 처음 쓰기 시작할 때의 목표?는, 이러한 점을 말하고 싶었다:
크리마는 Ansible 을 쓰고 있다. 크리마는 Datadog 을 쓰고 있다. 크리마는 Kafka 도 쫌 쓰고 있다. 누가 봤을진 모르지만(우리 회사 사람들은 봤을까 싶다..), 그래도 목표한 바는 글에 잘 쓴거 같다.
글 쓴 후 아쉬운 점을 복기하자면, 참고한 원 글에선 outlier detection 알람을 걸었다고 한다(정확히 알람일진 모르겠지만, 내 생각에 티켓 정도로 보내면 좋을거 같다).</description></item></channel></rss>